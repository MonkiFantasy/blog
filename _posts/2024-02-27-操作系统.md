---
title: 操作系统一轮复习
type: article
tags: 考研 操作系统 一轮
---

# 操作系统

##  操作系统四大特征

**并发** ：区别于并行，并发微观上不是同时发生
**共享**：多个进程对资源的共享 分为互斥共享和 同时共享
**虚拟**：虚拟内存技术 把比内存大的程序加载到内存中（虚拟存储器 空分复用技术）
虚拟处理器 把多个程序加载到单核cpu （时分复用技术）
**异步**：操作系统调度的顺序不同，所用的时间也不同

- 没有并发和共享，就没有虚拟和异步

## 操作系统发展历程

**手工操作阶段** 纸袋机 人机速度矛盾资源利用率低

**批处理阶段—— 单道批处理系统** 磁带机 解决了人机速度矛盾，但同时还是只有一个程序能执行，io时cpu仍然在等待
**批处理阶段——多道批处理** 并发的运行 cpu计算的同时进行另一个程序io 资源利用率得到更大提升 但是仍不能实现人机交互（程序不能改参数，调试等）
**分时操作系统** 解决了人机交互问题，以时间片轮流为各个用户服务各用户对计算机操作相互独立 但仍不能优先处理紧急任务
**实时操作系统** 能优先相应紧急任务 及时性 可靠性
分为

- 硬实时（必须严格的在规定时间内完成）
- 软实时（能接受偶尔违反时间规定）

## 区分指令（处理器能识别的最小命令）和命令
cpu 划分为内核态（可以执行特权指令） 和 用户态（只能执行非特权指令）存在程序状态字寄存器PSW中
用户态执行特权指令会触发中断信号 转换到内核态

## 中断的作用 

- 中断是让操作系统夺回cpu使用权的唯一途径
- 如果没有中断，cpu会一直执行一个应用程序

## 中断的分类 

**内中断** （也称异常、例外）
与当时执行指令有关，信号来源于cpu内部 

- 陷阱、陷入（trap）——非特权指令
- 故障(fault)
- 终止(abort)

当时执行指令非法或使用系统调用（使用trap陷入指令）
**外中断**（也称“中断”——狭义的中断）
与当前执行指令无关，信号来源于cpu外部

- 时钟中断（中断机制下并发执行）
- I/O中断

## 中断机制的基本原理

- 检查中断信号
- 找到对应的中断处理程序

## 什么是系统调用

操作系统向应用程序提供的接口，向上提供系统调用，使上层程序能够请求内核的服务

系统调用和库函数的区别？

为什么系统调用是必须的？

什么功能要用到系统调用？ 与共享资源有关的操作

## 操作系统体系结构

**大内核** 与管理相关的功能模块被划分在内核态

性能高，难以维护

**微内核** 与管理相关的功能模块被划分在用户态

微内核需要频繁地进行用户态和核心态切换，性能低

容易维护

**分层结构** 把内核分层，最底层是硬件，最高层是用户接口，每层可调用更低一层 

便于调试验证，分层验证，易于扩充和维护

缺点：仅可调用相邻层，难以合理定义各层边界

不能跨层调用，系统调用执行时间长，效率低

**模块化** 将内核划分为多个模块，各模块直接相互协作

内核 = 主模块 + 可加载内核模块

优点：

1. 模块间逻辑清晰，易于维护，确定模块间接口后可多模块同时开发
2. 可以动态加载新的模块
3. 任何模块都能直接调用其它模块，无需采用消息传递进行通信，效率高

缺点：

1. 模块间的接口未必合理实用
2. 模块间相互依赖，更难调试和验证

**外核（Exokernel）**

？

## 操作系统引导

开机时，怎么让操作系统运行起来

## 虚拟机

使用虚拟化技术，将一台物理机虚拟化为多台虚拟机器

VMM（Virtual Machine Monitor)

第一类VMM:直接运行在硬件上

第二类VMM:运行在宿主操作系统上

## 进程

动态的，程序的一次执行过程

进程的组成——**PCB（Process Control Block）、程序段、数据段**

PCB包括：

PCB是进程存在的唯一标准，当进程被创建时，操作系统为其创建PCB,当进程结束时，会回收该PCB

程序段包括程序的代码

数据段包含运行过程中产生的各种数据，如程序中定义的变量

- PCB是给操作系统用的
- 程序段数据段是给程序自己用的

程序是如何运行的？

进程实体（进程映像）

进程是进程实体的运动状态，是系统进行资源分配和调度的独立单位

**进程的特征**

- 动态性
- 并发性
- 独立性
- 异步性
- 结构型

## 进程的状态和转换

**创建态**：操作系统为进程分配资源、初始化PCB

**就绪态**：进程创建完成，尚未分配cpu资源

**运行态：**内存中存在多个就绪态的进程，cpu空闲时，操作系统就会选择一个就绪进程，让它上处理机运行

**阻塞态：**运行态的进程不具备运行条件，等待某个事件完成

**终止态：**进程运行结束，或运行过程中遇到不可修复的错误，操作系统回收进程的资源、撤销PCB

转换略

## 进程控制

实现进程间状态转换

- 如何实现进程控制？

  使用**原语**，因为进程状态转换需要**一气呵成**（否则可能PCB中state值发送转换，但PCB实际上还处于原先的状态队列里）

- 如何实现原语的原子性？

  原语执行具有原子性，执行过程一气呵成，期间不允许会中断

  原语是一种特殊的程序

  使用**开中断指令**和**关中断指令**这两个**特权指令**实现

**创建原语**（操作系统创建一个进程时使用的原语）

1. 申请空白PCB
2. 为新进程分配资源
3. 初始化PCB
4. 将PCB插入就绪队列（创建态->就绪态）

引起创建的事件：略

**撤销原语**（就绪态/阻塞态/运行态->终止态）

1. 从PCB进程找到终止进程的PCB
2. 若进程正在运行，则立即剥夺CPU将CPU分配给其它进程
3. 终止其所有子进程（进程间的关系是树型进程）
4. 将该进程的所有资源归还给父进程或操作系统
5. 删除PCB

引起撤销的事件：略

**阻塞原语**（运行态->阻塞态）

略

**唤醒原语**（阻塞态->就绪态）

略

**唤醒原语和阻塞原语必须成对使用**

**切换原语**（运行态<->就绪态）

略

## 进程通信

进程间通信（Inter-Progress Communication,**IPC**)：两个或多个进程间产生数据交互

- 为什么进程通信需要操作系统支持？

  进程是分配资源的单位（包括内存地址空间），因此各进程拥有的内存地址空间相互独立，

  为了保证安全，一个进程不能访问另一个进程的地址空间。

**共享存储**：进程A和B通过**共享内存区**进行通信（需要保证各进程共享内存区访问**互斥**）

- 基于数据结构共享（低级通信）
- 基于存储区共享（高级通信）

**消息传递**：进程之间以格式化的信息（Message）为单位，进程通过操作系统提供的“发送消息send(A,msg)、接收消息receive(B,&msg)”两个**原语**进行数据换

Message=消息头（发送进程id，接收进程id，消息长度等）+消息体

- 直接通信方式(点名道姓的消息传递->指明发送到哪个进程)
- 间接通信方式（以信箱作为中间实体进行消息传递->指明发送到哪个信箱）

**管道通信**：pipe,类比水管，管道是一个特殊的共享文件，是一个大小固定的内存缓冲区 A写数据--->管道---->B读数据

- 数据流向是单向的（**半双工通信**），要实现全双工，需要设置两个管道
- 各进程要互斥的访问管道
- 管道写**满**时，**写进程将阻塞**，直到读进程将管道中数据取走，即可**唤醒写进程**
- 管道为**空**时，**读进程将阻塞**，直到写进程往管道中写入数据，即可**唤醒读进程**
- 暂时略？

>Enter your message:
>管道通信为什么要各进程间互斥
>
>Model response (Model ERNIE-Bot-turbo):
>管道通信中各进程间需要互斥的原因是为了保证数据的安全性和完整性。在管道通信中，多个进程可以通过管道进行通信，但是每个进程
>对管道的访问应该是互斥的，以确保每个进程只处理一次管道中的数据，避免数据冲突和竞争条件的发生。
>
>当多个进程同时访问同一个管道时，如果不对访问进行互斥控制，可能会出现以下问题：
>
> 1 数据冲突：如果多个进程同时向管道中写入数据，可能会出现数据覆盖或数据丢失的情况，导致数据的不完整和不准确。
> 2 竞争条件：如果多个进程同时从管道中读取数据，可能会出现读取到其他进程尚未处理的数据的情况，导致数据的混乱和不一致。
>
>因此，为了保证管道通信的可靠性和稳定性，各进程间需要互斥地访问管道，以确保数据的安全性和完整性。
>
>First token latentcy: 1.97s, Total latency: 4.48s.
>Input token: 1424, Output token: 176, Total token: 1600.
>
>Enter your message:
>管道通信本身不就是一个进程读另一个进程写吗，为什么要互斥
>
>Model response (Model ERNIE-Bot-turbo):
>管道通信本身确实是一个进程读另一个进程写的机制，但是这种通信方式也存在竞争条件的问题。
>
>当多个进程同时读写管道时，可能会出现数据冲突和竞争条件，导致数据的不完整和不准确。这是因为管道中的数据是共享的，多个进程
>可以同时访问和修改它。如果不对访问进行互斥控制，就可能出现一个进程在写入数据时，其他进程也在读取或写入数据，导致数据被覆
>盖或丢失。
>
>因此，为了保证管道通信的可靠性和稳定性，需要采取互斥的访问机制，确保每个进程只处理一次管道中的数据，避免数据冲突和竞争条
>件的发生。这样不仅可以保证数据的安全性和完整性，还可以提高管道通信的效率和质量。
>
>First token latentcy: 0.87s, Total latency: 3.10s.
>Input token: 1615, Output token: 148, Total token: 1763.



**管道通信和共享存储的区别:**

共享存储，在共享内存中随机写入读取

管道通信，在缓冲区中先入先出读取（循环队列）

## 线程

有的进程可能需要同时做很多事（如qq聊天与视频通话并发），而传统的线程只能串行执行一系列程序，因此引入了线程，增加并发度

- 传统的进程是程序执行流的最小单位
- 引入线程后，线程成为了程序执行流的最小单位
- 可以把线程理解为轻量级进程

引入线程后带来的变化？

略

线程的属性

略

## 线程的实现方式

**用户级线程(User-Level Thread,ULT)**:早期操作系统只支持进程，线程通过线程库实现，运行在用户态（逻辑上的线程）

123略

4优缺点：略

**内核级线程（Kernel-Level Thread，KLT,又称"内核支持的线程"）**

1234略



**多线程模型**

1. 一对一模型：一个用户级线程映射到一个内核级线程

   略

2. 多对一模型：多个用户级线程映射到一个内核级线程

   略

3. 多对多模型：n个用户级线程映射到m个内核级线程（n>=m)

   略

- 用户线程理解为**代码逻辑**的载体
- 内核级线程理解为**运行机会**的载体

## 线程的状态与转换

略，类比进程

状态和转换

组织和控制

## 处理机调度概念，层次

调度：一堆任务要处理，由于资源限制，无法同时处理，因此要确定某种规则来确定处理的顺序

**调度的三个层次**

**高级调度（作业调度）**

作业：

**中级调度（内存调度）**

挂起状态：内存不够时将进程的数据调到外存中等待，等内存空闲或进程需要运行时再重新调入内存，等待的进程状态为挂起状态

按照某种策略决定将哪个处于挂起状态的进程重新调入内存

**低级调度（进程调度、处理机调度）**

进程间切换x





**进程的挂起态和七状态模型：**

略 就绪挂起 阻塞挂起



**挂起和阻塞区别：**

- 两种都状态是不能获得cpu的服务

- 挂起的进程映像在外存中
- 阻塞的进程映像在内存中

**三种调度的联系**、**对比**：

略

## 进程调度的时机 切换过程 调度方式

